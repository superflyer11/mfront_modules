@DSL Implicit;
@Behaviour DruckerPragerCap;
@Author Thomas Helfer;
@Description{
  A simple implementation of a perfect
  plasticity behaviour using the
  Drucker-Prager yield criterion
  closed by a cap.
};

// Define material properties for elasticity
@MaterialProperty stress young_modulus;
young_modulus.setGlossaryName("YoungModulus");
@MaterialProperty real poisson_ratio;
poisson_ratio.setGlossaryName("PoissonRatio");

// @StateVariable StrainStensor eel;
// eel.setGlossaryName("ElasticStrain");

@StateVariable strain p[2];
p.setGlossaryName("EquivalentPlasticStrain");

@LocalVariable bool bpl[2];
@LocalVariable real tg;
@LocalVariable real R;

@MaterialProperty stress d;
@MaterialProperty real beta;
@MaterialProperty stress pa;
@MaterialProperty stress pb;

@InitLocalVariables {
  tg = tan(beta);
  R = (pa - pb) / (d - pa * tg);
}

@Predictor {
    // Initialize elasticity parameters
    const auto lambda = computeLambda(young_modulus, poisson_ratio);
    const auto mu = computeMu(young_modulus, poisson_ratio);

    // Elastic prediction: compute trial stress based on strain increment
    eel += deto; // Update elastic strain incrementally
    const auto sigel = lambda * trace(eel) * Stensor::Id() + 2 * mu * eel; // Hooke's law for trial stress

    // Drucker-Prager check for plasticity based on trial elastic stress
    const auto prel = trace(sigel) / 3;
    const auto qel = sigmaeq(sigel);
    bpl[0] = (qel + prel * tg - d > 0) && (prel > pa);

    // Cap surface check for plasticity
    const auto seq_c = sqrt(power<2>(prel - pa) + power<2>(R * qel));
    bpl[1] = (seq_c > (pa - pb)) && (prel <= pa);
}

@Integrator {
    constexpr const auto id = Stensor::Id();
    constexpr const auto id4 = Stensor4::Id();
    constexpr const auto id_x_id = Stensor4::IxI();
    constexpr const auto M = Stensor4::M();
    const auto seps = real(1.e-12) * young_modulus;

    // Initialize elasticity parameters
    const auto lambda = computeLambda(young_modulus, poisson_ratio);
    const auto mu = computeMu(young_modulus, poisson_ratio);

    // Check if plasticity has occurred
    if ((bpl[0]) || (bpl[1])) {
        const auto pr = trace(sig) / 3;
        const auto q = sigmaeq(sig);
        const auto iq = 1 / max(q, seps);
        const auto nq = eval(3 * deviator(sig) * (iq / 2));
        const auto dnq = eval((M - (nq ^ nq)) * iq);

        if (bpl[0]) {
            const auto n = eval(nq + (tg / 3) * id);
            feel += dp[0] * n;
            fp(0) = (q + pr * tg - d) / young_modulus;

            // Update the Jacobian matrix (for the plastic correction)
            dfeel_ddeel += 2 * mu * theta * dp[0] * dnq;
            dfeel_ddp(0) = n;
            dfp_ddp(0, 0) = 0;
            dfp_ddeel(0) = (2 * mu * theta / young_modulus) * n + (tg * theta * lambda / young_modulus) * id;
        }
        if (bpl[1]) {
            const auto seq_c = sqrt(power<2>(pr - pa) + power<2>(R * q));
            const auto iseq_c = 1 / max(seq_c, seps);
            const auto n = eval(((pr - pa) * (id / 3) + R * R * q * nq) * iseq_c);
            const auto dn = (Stensor4::IxI() / 9 + R * R * M - (n ^ n)) * iseq_c;
            const auto De = 2 * mu * id4 + lambda * id_x_id;
            feel += dp[1] * n;
            fp(1) = (seq_c - R * (d - pa * tg)) / young_modulus;

            // Update the Jacobian matrix (for the plastic correction)
            dfeel_ddeel += theta * dp[1] * dn * De;
            dfeel_ddp(1) = n;
            if (std::abs(seq_c) < seps) {
                dfp_ddp(1, 1) = 1;
            } else {
                dfp_ddp(1, 1) = 0;
            }
            dfp_ddeel(1) = theta * (n | De) / young_modulus;
        }
    } else {
        // If elastic, apply standard elasticity stress update
        sig = lambda * trace(eel) * Stensor::Id() + 2 * mu * eel;
    }
}
@AdditionalConvergenceChecks {
    if (converged) {
        if (bpl[0]) {
            if (dp[0] < 0) {
                converged = bpl[0] = false;
            }
        } else {
            const auto pr = trace(sig) / 3;
            const auto q = sigmaeq(sig);
            if (q + pr * tg > d) {
                converged = false;
                bpl[0] = true;
            }
        }
        if (bpl[1]) {
            if (dp[1] < 0) {
                converged = bpl[1] = false;
            }
        } else {
            const auto pr = trace(sig) / 3;
            const auto q = sigmaeq(sig);
            const auto seq_c = sqrt(power<2>(pr - pa) + power<2>(R * q));
            if ((seq_c > pa - pb) && (pr < pa)) {
                converged = false;
                bpl[1] = true;
            }
        }
    }
}

@TangentOperator // because no Brick StandardElasticity
{
    // Initialize elasticity parameters
    const auto lambda = computeLambda(young_modulus, poisson_ratio);
    const auto mu = computeMu(young_modulus, poisson_ratio);
    if ((smt == ELASTIC) || (smt == SECANTOPERATOR))
    {
        Dt = Dt = lambda * Stensor4::IxI() + 2 * mu * Stensor4::Id();
        // Dt = dsig_deel;
    }
    else if (smt == CONSISTENTTANGENTOPERATOR)
    {
        Stensor4 Je;
        getPartialJacobianInvert(Je);
        Dt = (lambda * Stensor4::IxI() + 2 * mu * Stensor4::Id()) * Je;
        // Stensor4 Je;
        
        // getPartialJacobianInvert(Je);
        // Dt = dsig_deel * Je;
    }
    else
    {
        return false;
    }
}
